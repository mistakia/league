#!/usr/bin/env node

import fs from 'fs/promises'
import path from 'path'
import { fileURLToPath } from 'url'

import {
  scoring_formats,
  league_formats
} from '#libs-shared/league-format-definitions.mjs'
import generate_scoring_format_hash from '#libs-shared/generate-scoring-format-hash.mjs'
import generate_league_format_hash from '#libs-shared/generate-league-format-hash.mjs'

const __dirname = path.dirname(fileURLToPath(import.meta.url))
const project_root = path.join(__dirname, '..')

// Validate format name follows snake_case convention
const validate_format_name = (name) => {
  const valid_pattern = /^[a-z0-9_]+$/
  return valid_pattern.test(name)
}

// Generate scoring format hash using the existing utility
const generate_scoring_hash = (config) => {
  const result = generate_scoring_format_hash(config)
  return result.scoring_format_hash
}

// Generate league format hash using the existing utility
const generate_league_hash = (config, scoring_format_hash) => {
  const result = generate_league_format_hash({
    ...config,
    scoring_format_hash
  })
  return result.league_format_hash
}

// Process scoring formats
const process_scoring_formats = () => {
  const processed = {}
  const errors = []

  for (const [name, format] of Object.entries(scoring_formats)) {
    // Validate name
    if (!validate_format_name(name)) {
      errors.push(`Invalid format name: "${name}" - must be snake_case`)
      continue
    }

    // Validate required fields
    if (!format.label) {
      errors.push(`Missing label for format: "${name}"`)
      continue
    }

    // Determine hash
    let hash
    if (format.hash) {
      // Direct hash provided
      if (!/^[a-f0-9]{64}$/i.test(format.hash)) {
        errors.push(
          `Invalid hash format for "${name}" - must be 64-character hex string`
        )
        continue
      }
      hash = format.hash
    } else if (format.config) {
      // Generate hash from config
      hash = generate_scoring_hash(format.config)
    } else {
      errors.push(`Format "${name}" must have either 'hash' or 'config' field`)
      continue
    }

    processed[name] = {
      hash,
      label: format.label,
      description: format.description || ''
    }
  }

  return { processed, errors }
}

// Process league formats
const process_league_formats = (processed_scoring_formats) => {
  const processed = {}
  const errors = []

  for (const [name, format] of Object.entries(league_formats)) {
    // Validate name
    if (!validate_format_name(name)) {
      errors.push(`Invalid format name: "${name}" - must be snake_case`)
      continue
    }

    // Validate required fields
    if (!format.label) {
      errors.push(`Missing label for format: "${name}"`)
      continue
    }

    // Determine hash and resolve scoring format
    let hash
    let scoring_format_hash = null

    if (format.hash) {
      // Direct hash provided
      if (!/^[a-f0-9]{64}$/i.test(format.hash)) {
        errors.push(
          `Invalid hash format for "${name}" - must be 64-character hex string`
        )
        continue
      }
      hash = format.hash
    } else if (format.config) {
      // Generate hash from config

      // Resolve scoring format hash
      if (format.scoring_format) {
        if (processed_scoring_formats[format.scoring_format]) {
          scoring_format_hash =
            processed_scoring_formats[format.scoring_format].hash
        } else {
          errors.push(
            `Scoring format "${format.scoring_format}" not found for league format "${name}"`
          )
          continue
        }
      } else {
        errors.push(
          `League format "${name}" with config must specify scoring_format`
        )
        continue
      }

      hash = generate_league_hash(format.config, scoring_format_hash)
    } else {
      errors.push(`Format "${name}" must have either 'hash' or 'config' field`)
      continue
    }

    // Validate scoring format reference (for non-config formats)
    if (
      format.scoring_format &&
      !format.config &&
      !processed_scoring_formats[format.scoring_format]
    ) {
      errors.push(
        `Invalid scoring_format reference "${format.scoring_format}" for league format "${name}"`
      )
      continue
    }

    processed[name] = {
      hash,
      label: format.label,
      description: format.description || '',
      scoring_format: format.scoring_format || null
    }
  }

  return { processed, errors }
}

// Generate file content
const generate_file_content = (type, formats) => {
  const timestamp = new Date().toISOString()

  let content = `// Auto-generated named ${type} format constants
// Generated at: ${timestamp}
// DO NOT EDIT THIS FILE MANUALLY
// To make changes, edit libs-shared/league-format-definitions.mjs and run: yarn generate:formats

`

  if (type === 'scoring') {
    content += 'export const named_scoring_formats = {\n'
  } else {
    content += 'export const named_league_formats = {\n'
  }

  // Sort formats by name for consistent output
  const sorted_entries = Object.entries(formats).sort((a, b) =>
    a[0].localeCompare(b[0])
  )

  for (const [name, format] of sorted_entries) {
    content += `  ${name}: {\n`
    content += `    hash: '${format.hash}',\n`
    content += `    label: '${format.label}',\n`
    content += `    description: '${format.description}'`

    if (type === 'league' && format.scoring_format) {
      content += `,\n    scoring_format: '${format.scoring_format}'`
    }

    content += '\n  },\n'
  }

  // Remove trailing comma and close
  content = content.slice(0, -2) + '\n}\n'

  return content
}

// Generate markdown documentation
const generate_markdown_documentation = (
  scoring_formats_processed,
  league_formats_processed
) => {
  const timestamp = new Date().toISOString()

  let content = `# Named Scoring and League Formats

*Generated at: ${timestamp}*

This document shows the configuration for each named format in the system.

`

  // League format summary
  const league_entries = Object.entries(league_formats_processed).sort((a, b) =>
    a[0].localeCompare(b[0])
  )
  if (league_entries.length > 0) {
    content += `## League Format Summary

| Name | Description | Details |
|------|-------------|---------|
`

    for (const [name, format] of league_entries) {
      const description = format.description || 'No description'
      content += `| \`${name}\` | ${description} | [View Details](#${name.replace(/_/g, '-')}) |\n`
    }

    content += '\n'
  }

  // Scoring format summary
  const scoring_entries = Object.entries(scoring_formats_processed).sort(
    (a, b) => a[0].localeCompare(b[0])
  )
  if (scoring_entries.length > 0) {
    content += `## Scoring Format Summary

| Name | Description | Details |
|------|-------------|---------|
`

    for (const [name, format] of scoring_entries) {
      const description = format.description || 'No description'
      content += `| \`${name}\` | ${description} | [View Details](#${name.replace(/_/g, '-')}-1) |\n`
    }

    content += '\n'
  }

  // League format details
  if (league_entries.length > 0) {
    content += `## League Format Details

`

    for (const [name, format] of league_entries) {
      content += `### ${name}

**Label:** ${format.label}  
**Description:** ${format.description || 'No description'}  
**Hash:** \`${format.hash}\`

`

      // Get actual format properties from the original input
      const input_format = league_formats[name]
      if (input_format && input_format.config) {
        content += `**Configuration:**
| Property | Value | Description |
|----------|-------|-------------|
`
        const config = input_format.config
        const property_descriptions = {
          num_teams: 'Number of teams in the league',
          sqb: 'Starting QB positions',
          srb: 'Starting RB positions',
          swr: 'Starting WR positions',
          ste: 'Starting TE positions',
          srbwr: 'Starting RB/WR flex positions',
          srbwrte: 'Starting RB/WR/TE flex positions',
          sqbrbwrte: 'Starting superflex (QB/RB/WR/TE) positions',
          swrte: 'Starting WR/TE flex positions',
          sdst: 'Starting D/ST positions',
          sk: 'Starting K positions',
          bench: 'Bench positions',
          ps: 'Practice squad positions',
          ir: 'IR positions',
          cap: 'Salary cap',
          min_bid: 'Minimum bid amount'
        }

        for (const [prop, value] of Object.entries(config)) {
          const desc = property_descriptions[prop] || prop
          content += `| \`${prop}\` | ${value} | ${desc} |\n`
        }

        if (format.scoring_format) {
          content += `\n**Scoring Format:** [\`${format.scoring_format}\`](#${format.scoring_format.replace(/_/g, '-')}-1)

`
        }
      } else {
        content += `*Hash-based format - configuration not available*

`
      }
    }
  }

  // Scoring format details
  if (scoring_entries.length > 0) {
    content += `## Scoring Format Details

`

    for (const [name, format] of scoring_entries) {
      content += `### ${name}

**Label:** ${format.label}  
**Description:** ${format.description || 'No description'}  
**Hash:** \`${format.hash}\`

`

      // Get actual format properties from the original input
      const input_format = scoring_formats[name]
      if (input_format && input_format.config) {
        content += `**Configuration:**
| Property | Value | Description |
|----------|-------|-------------|
`
        const config = input_format.config
        const property_descriptions = {
          pa: 'Points per passing attempt',
          pc: 'Points per passing completion',
          py: 'Points per passing yard',
          ints: 'Points per interception thrown',
          tdp: 'Points per passing touchdown',
          ra: 'Points per rushing attempt',
          ry: 'Points per rushing yard',
          tdr: 'Points per rushing touchdown',
          rec: 'Points per reception',
          rbrec: 'Points per RB reception',
          wrrec: 'Points per WR reception',
          terec: 'Points per TE reception',
          recy: 'Points per receiving yard',
          tdrec: 'Points per receiving touchdown',
          twoptc: 'Points per two-point conversion',
          fuml: 'Points per fumble lost',
          prtd: 'Points per punt return touchdown',
          krtd: 'Points per kick return touchdown'
        }

        for (const [prop, value] of Object.entries(config)) {
          const desc = property_descriptions[prop] || prop
          content += `| \`${prop}\` | ${value} | ${desc} |\n`
        }

        content += '\n'
      } else {
        content += `*Hash-based format - configuration not available*

`
      }
    }
  }

  return content
}

// Main generation function
const main = async () => {
  console.log('Generating named format constants...')

  const all_errors = []

  // Process scoring formats
  console.log('\nProcessing scoring formats...')
  const { processed: scoring, errors: scoring_errors } =
    process_scoring_formats()
  all_errors.push(...scoring_errors)
  console.log(`- Processed ${Object.keys(scoring).length} scoring formats`)

  // Process league formats
  console.log('\nProcessing league formats...')
  const { processed: league, errors: league_errors } =
    process_league_formats(scoring)
  all_errors.push(...league_errors)
  console.log(`- Processed ${Object.keys(league).length} league formats`)

  // Check for errors
  if (all_errors.length > 0) {
    console.error('\nErrors found:')
    all_errors.forEach((error) => console.error(`- ${error}`))
    process.exit(1)
  }

  // Generate output files
  const libs_dir = path.join(project_root, 'libs-shared')
  const docs_dir = path.join(project_root, 'docs')

  // Generate scoring formats file
  const scoring_content = generate_file_content('scoring', scoring)
  const scoring_path = path.join(
    libs_dir,
    'named-scoring-formats-generated.mjs'
  )
  await fs.writeFile(scoring_path, scoring_content, 'utf8')
  console.log(`\nGenerated: ${path.relative(project_root, scoring_path)}`)

  // Generate league formats file
  const league_content = generate_file_content('league', league)
  const league_path = path.join(libs_dir, 'named-league-formats-generated.mjs')
  await fs.writeFile(league_path, league_content, 'utf8')
  console.log(`Generated: ${path.relative(project_root, league_path)}`)

  // Generate markdown documentation
  const markdown_content = generate_markdown_documentation(scoring, league)
  const markdown_path = path.join(docs_dir, 'named-formats.md')
  await fs.writeFile(markdown_path, markdown_content, 'utf8')
  console.log(`Generated: ${path.relative(project_root, markdown_path)}`)

  console.log('\nFormat generation completed successfully!')
}

// Run if called directly
if (process.argv[1] === fileURLToPath(import.meta.url)) {
  main().catch((error) => {
    console.error('Generation failed:', error)
    process.exit(1)
  })
}

export default main
